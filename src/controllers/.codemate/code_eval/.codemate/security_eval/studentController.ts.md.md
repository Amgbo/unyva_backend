# Security Vulnerability Report

This report analyzes the supplied code for **security vulnerabilities only**. Each issue references specific risks and provides actionable recommendations.

---

## 1. Sensitive Data Exposure via Logging

**Risk:**  
Extensive use of `console.log` throughout the codebase, often logging sensitive information such as student objects, password hashes, request bodies, and JWT secret status. If this code runs in production, these logs could be accessed, resulting in sensitive data exposure.

**Recommendations:**
- Remove or strictly control all debug logs before deployment.
- NEVER log password hashes, authentication tokens, or full user objects.
- Use a logging library supporting log levels and production-safe output (e.g., Winston, Bunyan).

---

## 2. Hardcoded / Weak JWT Secret Management

**Risk:**  
Use of a weak, hardcoded fallback JWT secret if the environment variable is not set means JWTs can be guessed or generated by attackers, leading to authentication bypass.

**Recommendations:**
- Make JWT secret a mandatory environment variable.  
- Abort startup if not set.  
- Use securely generated, long random secrets.

---

## 3. Password Policy and Hashing

**Risks:**
- No password policy (e.g., minimum length, complexity) enforced during registration, enabling weak passwords.
- Bcrypt salt rounds are set to a fixed, low number without the ability to tune for increased security.
- No rate limiting on registration/login, enabling brute force attacks.

**Recommendations:**
- Enforce strong password policy in registration (length and complexity).
- Make salt rounds configurable via environment variable.
- Apply rate limiting middleware to authentication endpoints (e.g., express-rate-limit).

---

## 4. File Upload Vulnerabilities: Validation/Sanitization

**Risks:**
- File uploads (e.g., profile picture, ID card) are not validated for allowed MIME type or restricted for file size, allowing users to upload malicious files.
- Filenames are not properly sanitized, risking path traversal exploits and stored XSS.

**Recommendations:**
- Strictly validate allowed MIME types and file sizes.
- Sanitize or randomize file names before saving.
- Validate all uploaded files at backend before usage.

---

## 5. Insecure Email Verification: Token Lifetime

**Risk:**  
Email verification tokens do not expire. Attackers could reuse an old or leaked token to verify accounts at any time, or brute-force token guessing. 

**Recommendations:**
- Store a token creation timestamp.
- Enforce a reasonable expiry (e.g., 24 hours) on verification tokens.

---

## 6. Excessive Data Exposure in SQL Queries

**Risk:**  
Use of `SELECT *` can expose unnecessary or sensitive columns (e.g., password hashes, verification tokens) to business logic or, via coding errors, to clients.

**Recommendations:**
- Always select only required columns in queries.
- Never expose sensitive fields to API responses.

---

## 7. Weak Email Verification Enforcement

**Risk:**  
Block checking for `student.is_verified` is commented out. This allows unverified users (possibly with unowned, mis-typed, or attacker-controlled emails) to access authenticated endpoints.

**Recommendations:**
- Enforce email verification before login. 
- Never allow unverified accounts access to privileged operations.

---

## 8. Unvalidated Query Parameters

**Risk:**  
Direct use of unsanitized `req.query.token` parameters enables XSS, malformed token abuse, or token enumeration attacks.

**Recommendations:**
- Enforce strict validation (type and pattern) on all tokens received via query.
- Reject queries with tokens not matching expected format.

---

## 9. Race Condition: Account Creation

**Risk:**  
Check-then-insert pattern for student existence can permit race conditions (two concurrent creates). An attacker may bypass uniqueness.

**Recommendations:**
- Database must enforce unique constraints on email and student ID.
- Handle duplicate-row constraint violation errors gracefully at API level.

---

## 10. Type Safety and Authorization

**Risk:**  
Use of `any` weakens static guarantees about authenticated user object on `req`. Missing authorization checks or mistaken property access can leak or corrupt data.

**Recommendations:**
- Use strong TypeScript types for authenticated request objects.
- Enforce type-safe access for `student_id` and other sensitive properties.

---

## Vulnerability Severity Summary

| Vulnerability                                  | Severity        |
|------------------------------------------------|-----------------|
| Sensitive data/logging                         | High            |
| Hardcoded/weak JWT secret                      | Critical        |
| Password policy                                | Medium-High     |
| File upload validation                         | High            |
| Verification token lifetime                    | High            |
| SELECT * queries / data exposure               | High            |
| Email verification not enforced                | Critical        |
| Query param validation                         | High            |
| Registration race condition                    | Medium-High     |
| Type safety on authentication                  | Medium          |

---

## Critical Recommendations

- **DO NOT deploy** with sensitive logging, hardcoded JWT secrets, or with verification checks disabled.
- **Implement validation and sanitization for all untrusted input:** file uploads, query params, request bodies.
- **Enable environment-based configuration** for all secrets and cryptographic settings (no weak or dev defaults).
- **Apply proper rate limiting and brute-force protection** to authentication endpoints.

---

*Remediate these vulnerabilities before moving to production to ensure confidentiality, integrity, and availability of user data.*

---

**End of Security Vulnerability Report**
